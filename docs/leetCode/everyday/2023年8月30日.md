---
title: 2023年8月30日
tag: 
    - 广度优先遍历
    - 哈希
  
---

> [1654. 到家的最少跳跃次数](https://leetcode.cn/problems/minimum-jumps-to-reach-home/description/)


# 思路
### 广度优先遍历+哈希
从题目可以直观的知道，本题可以使用广度优先遍历方法，遍历每一个step可以到达的所有点，进行判断即可。难点在于如何找到边界条件
1. 对于走过的点，我们可以添加到forbids中，这样避免重复路径
2. 对于最远距离，参考官方解题方法，我们直接用结论的6000（根本想不到啊）


# 解题方法
除了最远距离的论证，其他都直接使用标准的广度优先遍历写法，注意添加到 forbids  数组的时机，只在 可前进可后退 时添加即可

具体看代码~

# 复杂度

- 时间复杂度:  $O(nlogn)$

- 空间复杂度:  $O(n^2)$



# Code
```Java []
  /**
     * 广度优先遍历，
     * 最远的边界条件，使用 3*2000. 
     */
    class Solution {
        public int minimumJumps(int[] forbidden, int a, int b, int x) {
            int step=0;
            Set<Integer> forbids=new HashSet<>();
            for (int i : forbidden) {
                forbids.add(i);
            }
            Queue<int[]> queue=new LinkedList<>();
            queue.offer(new int[]{0,0});
            forbids.add(0);
            while (!queue.isEmpty()){
                step++;
                int size = queue.size();
                for (int i = 0; i < size; i++) {
                    int[] poll = queue.poll();
                    int next = poll[0] + a;

                    if (!forbids.contains(next)){
                        forbids.add(next);
                        if (next==x) return step;
                        //1.<x
                        // 2.>x  1.a-b>0 不需要 2.a-b<0 &&
                        if (next<x){
                            queue.offer(new int[]{next,0});

                        }else{
                            if (next<6000){
                                queue.offer(new int[]{next,0});
                            }
                        }
                    }

                    if (poll[1]==0){
                        next = poll[0] - b;
                        if (!forbids.contains(next)){

                            if (next==x) return step;
                            if (next>0){
                                queue.offer(new int[]{next,1});
                            }
                        }
                    }
                }
            }
            return -1;
        }
    }
```
