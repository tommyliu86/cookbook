---
title: 2023年8月24日
tag: 
    - 遍历
    - 深度优先
---

> LeetCode题目: [1267. 统计参与通信的服务器](https://leetcode.cn/problems/count-servers-that-communicate/description/)


# 思路
### 深度优先遍历
二维数组的题目，查找 面积、相邻点等问题，一般都可以看成是典型的深度优先遍历问题来求解，本题也可以使用相同思路
我们遍历数组，当点 p（i，j）==1时，深度遍历与 p 4个方向上有服务器的点，查找过程进行计数即可。

### 遍历+统计
通过深度优先遍历解法，我们可以看到本题与一般深度优先不一样的地方是，并未要求必须是点与点相邻才行，而是 行或列 上有相同的点，就可看作相连
因此可以考虑直接遍历统计 行和列 上的服务器数量，如果 行或列 上的数量 >1 ，就可以知道 该 行或列 上的服务器是有效的，有了 行或列 上的数据
我们就可以通过再次遍历 ，查找每个服务器， 通过服务器所在的 行或列 的服务器数量，判断该服务器是否有相连。

### 思路
遍历解法中，一般还是要考虑多次遍历的解决，数量少的情况下，遍历的时间复杂度很好！
思考下，题目是按照行、列有大于1个就可相连，因此这里可以先遍历一次，找到每行、每列的服务器数量，
剩下的思路，就是如何找到答案，
直观的思路是 ：我们如何找到一个服务器，在行和列上重复计数了，这样的话就会变复杂
那反过来，我们直接根据行、列的服务器数量，可以做什么事请?  如果一个服务器的行 or 列>1,那么表示服务器是有连接的，我们计数即可！！！

# 解题方法
### 深度优先遍历
没啥说的，直接标准模板解题即可

### 遍历+统计
 两次遍历，一次计算 行和列 ， 一次计算服务器即可。

# 复杂度
### 深度优先遍历
- 时间复杂度:  $O(nlogn)$

- 空间复杂度:  $O(1)$

### 遍历+统计
- 时间复杂度:  $O(n)$

- 空间复杂度:  $O(m+n)$

# Code
```Java []
//遍历
 class Solution {


        public int countServers(int[][] grid) {
            int[] xmark = new int[grid.length];
            int[] ymark = new int[grid[0].length];

            for (int i = 0; i < grid.length; i++) {
                for (int j = 0; j < grid[i].length; j++) {
                    if (grid[i][j] == 1) {
                        xmark[i]++;
                        ymark[j]++;
                    }
                }
            }
            int ans = 0;
            for (int i = 0; i < grid.length; i++)
                for (int j = 0; j < grid[i].length; j++)
                    if (xmark[i] > 1 || ymark[j] > 1) ans++;

            return ans;
        }

    }
```
```java []
 /**
     * 深度优先搜索，n*logn
     */
    class Solution1 {
        int[] steps = new int[]{0, 1, 0, -1, 0};

        public int countServers(int[][] grid) {

            int ans = 0;
            for (int i = 0; i < grid.length; i++) {
                for (int j = 0; j < grid[i].length; j++) {
                    if (grid[i][j] == 1) {
                        int a = dfs(i, j, grid);
                        if (a > 1) ans += a;
                    }
                }
            }
            return ans;
        }

        private int dfs(int i, int j, int[][] grid) {
            Queue<int[]> ps = new LinkedList<>();
            ps.add(new int[]{i, j});
            grid[i][j] = 0;
            int a = 1;
            while (!ps.isEmpty()) {
                int[] poll = ps.poll();
                for (int k = 1; k < steps.length; k++) {
                    int newi = poll[0] + steps[k - 1];
                    int newj = poll[1] + steps[k];
                    while (newi >= 0 && newi < grid.length && newj >= 0 && newj < grid[0].length) {
                        if (grid[newi][newj] == 1) {
                            ps.add(new int[]{newi, newj});
                            grid[newi][newj] = 0;
                            a++;
                        }
                        newi += steps[k - 1];
                        newj += steps[k];
                    }
                }
            }
            return a;
        }
    }
```    