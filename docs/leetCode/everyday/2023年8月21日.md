---
title: 2023年8月21日
---

> LeetCode题目: [2337. 移动片段得到字符串](https://leetcode.cn/problems/move-pieces-to-obtain-a-string/description/)


# 思路
从题目要求可知，需要把start中的字符进行移动匹配target，这就像是华容道，只是放到了一条线上。那我们只要思考start中每个标记是否能移动到target中相同的位置即可

# 解题方法
因为是要让start和target一样，因此我们是用双指针，遍历target中的位置上的标记，然后看start中是否有最近可移动的标记移动到相同位置。

我们从头开始找标记，找到target中的标记位置i1，start中的标记i，是否匹配的边界条件如下：

1. start[i]==target[i1]
2. char=='L',则i>=i1
3. char=='R',则i<=i1
4. 遍历完成之后判断是否有多余标记

# 复杂度
- 时间复杂度:  $O(n)$

- 空间复杂度:  $O(1)$

# Code
```Java []

 class Solution {
        public boolean canChange(String start, String target) {
            int i = 0, i1 = 0;
            int n = start.length();
            while (i1 < n) {

                //1.找到target中不是'_'的字符
                while (i1 < n && target.charAt(i1) == '_') {
                    i1++;
                }
                //2.找到start中不是'_'的字符
                while (i < n && start.charAt(i) == '_') {
                    i++;
                }
                //3.如果其中一个字符串的指针到达末尾，检查两个指针是否都到达末尾
                if (i1 == n || i == n) {
                    return i == n && i1 == n;
                }
                //4.检查两个字符是否相同，和是否满足'L'在右边，'R'在左边的条件
                if (start.charAt(i) != target.charAt(i1) || (start.charAt(i) == 'L' && i < i1) || (start.charAt(i) == 'R' && i > i1)) {
                    return false;
                }
                i++;
                i1++;
            }
            //5.检查最后一个指针在start中是否到达末尾
            while (i < n && start.charAt(i) == '_') {
                i++;
            }
            return i == n && i1 == n;
        }
    }
```
