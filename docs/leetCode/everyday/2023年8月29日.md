---
title: 2023年8月29日
tag: 
    - 动态规划
    - 哈希
  
---

> [823. 带因子的二叉树](https://leetcode.cn/problems/binary-trees-with-factors/description/)


# 思路
### 动态规划+哈希
我们先从题目的要求进行分析，求的是能够构建多少二叉树？我们按照节点情况进行分析:
1. 所有的一个节点的二叉树
2. 非一个节点的二叉树，此时必然有左、右子节点，且 `root=left*right` ，此时我们可以发现，我们只要找 三个数 并判断 是否满足乘法条件 即可。
   进一步，可以知道 left ，right < root 成立 ，因此，思考如何判断是否可以构成二叉树 我们只要从小到大 遍历数组， 并在小于 `arr[i]` 的元素中找到 两个元素 x 和 y ,满足 `x*y=arr[i]`


# 解题方法
根据分析我们可以总结以下规律：设dp[i]表示以arr[i] 为根的二叉树 的组合方法，那么 
$dp[i]=1 + dp[x]*dp[y]$ 
其中 arr[x]*arr[y]=arr[i] 

考虑题目元素数量不大于1000，我们可以使用一个hash表做记忆化搜索。

具体看代码~

# 复杂度

- 时间复杂度:  $O(n+logn)$

- 空间复杂度:  $O(2n)$



# Code
```Java []
  /**
     * dp 动态规划
     */
    class Solution {
        public int numFactoredBinaryTrees(int[] arr) {
            Arrays.sort(arr);
            long[] dps = new long[arr.length];
            Arrays.fill(dps, 1);
            Map<Integer, Integer> indez = new HashMap<>();

            long ans = 0;
            int mod = 1000_000_007;
            for (int i = 0; i < dps.length; i++) {
                indez.put(arr[i], i);
                int cur = arr[i];
                for (int j = 0; j < i && arr[j] * arr[j] <= arr[i]; j++) {
                    int pre = arr[j];
                    if (cur % pre == 0 && indez.containsKey(cur / pre)) {
                        Integer index = indez.get(cur / pre);
                        dps[i] += index == j ? dps[j] * dps[j] : 2 * dps[j] * dps[index];
                    }
                }
                ans = (ans + dps[i]) % mod;
            }
            return (int) ans;
        }
    }
```
