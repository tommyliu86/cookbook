---
title: 2023年8月23日
tag: 
    - 双指针
    - 二分查找
    - 哈希
---

> LeetCode题目: [1782. 统计点对的数目](https://leetcode.cn/problems/count-pairs-of-nodes/description/)


# 思路

题目要获取的是两个点连接的边的数量，如果我们不考虑其他约束和条件，本题其实就是在数组中查找指定数的题目，
一般我们都可以用 `双指针` 和 `二分查找` 的方法。

本题中，需要考虑的是 edge 的计算，我们直接遍历 edges 数组，可以计算出每个点连接的边，而假设 两个点 i、j,
通过 i 的 为 x，通过 j 的为 y，那么 query= x + y 正确吗？ 这里是不一定，原因是 如果 i、j 之间有edge = z 条，
我们的 x + y 中实际把 z 记录了两次，因此我们需要考虑的就是要把 z 修正掉。

如何修正 z ？ 如果在  `双指针` 和 `二分查找`  中就修正，那么 这两种方法就不能使用了，因为 这两个方法都依赖 `有序数组` ，

这里可以使用的是先计数，然后再通过遍历 edge 来进行修正。

# 解题方法
### 二分查找
- 遍历获取到每个点的边数
- 排序后，每个query，可以
     1. 从最小开始遍历，每个i，二分查找 query-i 的下标
     2. 大于query的i，后面的直接进行阶乘计算
### 双指针 
- 排序后，使用双指针
     1.双指针遍历，每次考虑的也是单点，不需要二分查找，代码更简单

# 复杂度
- 时间复杂度:  $O(n)$

- 空间复杂度:  $O(1)$

# Code
```Java []

 class Solution {
        public int[] countPairs(int n, int[][] edges, int[] queries) {
            int[] counts=new int[n+1];
            Map<Integer,Integer> edgMap=new HashMap<>();

            for (int i = 0; i < edges.length; i++) {
                for (int i1 : edges[i]) {
                    counts[i1]++;
                }
               int x= Math.min(edges[i][0],edges[i][1]);
               int y= Math.max(edges[i][0],edges[i][1]);
               
                edgMap.merge(x<<16|y,1,Integer::sum);
            }
            int[] origC = Arrays.copyOf(counts, counts.length);
            Arrays.sort(counts);
            int[] ans=new int[queries.length];
            for (int i = 0; i < queries.length; i++) {
                int query = queries[i];
                int x=1,y=n;
                while (x<y){
                    if (counts[x]+counts[y]>query){
                        ans[i]+=y-x;
                        y--;
                    }else{
                        x++;
                    }
                }
                //计算重复边的情况,我们的ans记录的是数对数量，因此如果边不满足情况，则需要减去这个数对
                for (Map.Entry<Integer, Integer> entry : edgMap.entrySet()) {
                    Integer k = entry.getKey();
                    Integer v = entry.getValue();
                    int count = origC[k >> 16] + origC[k & ((int) Math.pow(2, 16) - 1)];
                    if (count > query && count - v <= query) {
                        ans[i]--;
                    }
                }

            }
            return ans;
        }
    }
```
