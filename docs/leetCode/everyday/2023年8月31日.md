---
title: 2023年8月31日
tag: 
    - 排序+遍历
  
  
---

> [1761. 一个图中连通三元组的最小度数](https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/description/)


# 思路
### 排序+遍历
我们先从题目的要求进行分析，要求解的是三元组，也就是从数组中找3个点，条件是：1.每两个点之间有边。
因此我们需要
1. 一个数组保存每个点的度
2. 一个二维数组保存每两个点之间是否有边
有了这些，我们可以直接 遍历数组，暴力找到所有符合要求的三元组，然后计算结果即可。


# 解题方法
根据分析，我们用一个数组保存每个点的度 points[] ，一个二维数组 eds[][] 保存每两个点之间是否存在边
然后使用嵌套遍历，判断条件： eds[i][j]>0&&eds[i][k]>0&&eds[j][k]>0 ，使用 Math.min 方法保存结果即可



具体看代码~

# 复杂度

- 时间复杂度:  $O(n3)$

- 空间复杂度:  $O(n2)$



# Code
```Java []
  /**
     * 类记忆化搜索
     * 排序+遍历
     */
    class Solution {
        public int minTrioDegree(int n, int[][] edges) {
            int[] points=new int[n+1];
            int[][] eds=new int[n+1][n+1];
            for (int[] edge : edges) {
                points[edge[0]]++;
                points[edge[1]]++;
                eds[edge[0]][edge[1]]++;
                eds[edge[1]][edge[0]]++;
            }


            int ans=Integer.MAX_VALUE;
            for (int i = 1; i < n+1; i++) {

                if (points[i]<2) {
                    continue;
                }
                for (int j = i+1; j <= n; j++) {
                    if (eds[i][j]>0){
                        for (int k = j+1; k <= n; k++) {
                            if (eds[i][k]>0&&eds[j][k]>0){
                                ans=Math.min( points[i]+points[j]+points[k]-6,ans);
                            }
                        }
                    }
                }
            }
            return ans==Integer.MAX_VALUE?-1:ans;


        }
    }
```
