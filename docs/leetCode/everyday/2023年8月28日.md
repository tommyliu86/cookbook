---
title: 2023年8月28日
tag: 
    - 遍历
    - 双指针
---

> LeetCode题目: [57. 插入区间](https://leetcode.cn/problems/insert-interval/description/)


# 思路
### 遍历+双指针
分析题目，仍然是重合区间如何判断的问题，那我们考虑两个区间重合，分为两种情况
1. 区间相交
2. 区间包含
如何判断新区间和某个区间重合？ 由于区间有序，因此我们可以直接遍历每个区间，当 endi < newStart 时，肯定不重合
当newStart<=endi 时，表示新区间与当前区间重合，我们继续判断newEnd结束于哪里即可。


# 解题方法
直接遍历区间，通过条件判断是否重合：endi < newStart ，不重合则继续遍历

重合，则记录 min（newStart，starti） 为合并后区间的start，同时 max(newEnd,endi) 为合并后的end
然后我们使用一个新的指针 j ，向后遍历查找end 落入的区间情况。

注意边界条件：
1. 给定区间长度为0；
2. 新区间在 区间的 开头或尾部 且 不重合；

# 复杂度

- 时间复杂度:  $O(n)$

- 空间复杂度:  $O(1)$



# Code
```Java []
 class Solution {
        //start《ns《end 合并 到 start《nn《end or nn《start
        public int[][] insert(int[][] intervals, int[] newInterval) {
            if (intervals.length==0){
                return new int[][]{newInterval};
            }
            List<int[]> lists=new ArrayList<>();
            boolean merged=false;
            for (int i = 0; i < intervals.length; i++) {
                int start=intervals[i][0];
                int end=intervals[i][1];
                if (merged||end<newInterval[0]){
                    lists.add(intervals[i]);
                    continue;
                }

                if (newInterval[1]<start){
                    lists.add(newInterval);
                    lists.add(intervals[i]);
                }else{
                    start=Math.min(start,newInterval[0] );
                    end=Math.max(end,newInterval[1]);
                    int j=i+1;
                    while (j<intervals.length&&intervals[j][0]<=end){
                        end=Math.max(end,intervals[j][1]);
                        j++;
                    }
                    lists.add(new int[]{start,end});
                    i=j-1;
                }
                merged=true;

            }
            if (!merged){
                lists.add(newInterval);
            }
            int[][] ans=new int[lists.size()][2];
            for (int i = 0; i < ans.length; i++) {
                ans[i]=lists.get(i);
            }
            return ans;
        }
    }
```
