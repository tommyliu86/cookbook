import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as r,c as t,a as s,d as a,b as m,e as n}from"./app-a4abe009.js";const c={},d={href:"https://leetcode.cn/problems/binary-trees-with-factors/description/",target:"_blank",rel:"noopener noreferrer"},o=n('<h1 id="思路" tabindex="-1"><a class="header-anchor" href="#思路" aria-hidden="true">#</a> 思路</h1><h3 id="动态规划-哈希" tabindex="-1"><a class="header-anchor" href="#动态规划-哈希" aria-hidden="true">#</a> 动态规划+哈希</h3><p>我们先从题目的要求进行分析，求的是能够构建多少二叉树？我们按照节点情况进行分析:</p><ol><li>所有的一个节点的二叉树</li><li>非一个节点的二叉树，此时必然有左、右子节点，且 <code>root=left*right</code> ，此时我们可以发现，我们只要找 三个数 并判断 是否满足乘法条件 即可。<br> 进一步，可以知道 left ，right &lt; root 成立 ，因此，思考如何判断是否可以构成二叉树 我们只要从小到大 遍历数组， 并在小于 <code>arr[i]</code> 的元素中找到 两个元素 x 和 y ,满足 <code>x*y=arr[i]</code></li></ol><h1 id="解题方法" tabindex="-1"><a class="header-anchor" href="#解题方法" aria-hidden="true">#</a> 解题方法</h1>',5),p=s("p",null,[a("根据分析我们可以总结以下规律：设dp[i]表示以arr[i] 为根的二叉树 的组合方法，那么"),s("br"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"d"),s("mi",null,"p"),s("mo",{stretchy:"false"},"["),s("mi",null,"i"),s("mo",{stretchy:"false"},"]"),s("mo",null,"="),s("mn",null,"1"),s("mo",null,"+"),s("mi",null,"d"),s("mi",null,"p"),s("mo",{stretchy:"false"},"["),s("mi",null,"x"),s("mo",{stretchy:"false"},"]"),s("mo",null,"∗"),s("mi",null,"d"),s("mi",null,"p"),s("mo",{stretchy:"false"},"["),s("mi",null,"y"),s("mo",{stretchy:"false"},"]")]),s("annotation",{encoding:"application/x-tex"},"dp[i]=1 + dp[x]*dp[y]")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal"},"d"),s("span",{class:"mord mathnormal"},"p"),s("span",{class:"mopen"},"["),s("span",{class:"mord mathnormal"},"i"),s("span",{class:"mclose"},"]"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal"},"d"),s("span",{class:"mord mathnormal"},"p"),s("span",{class:"mopen"},"["),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mclose"},"]"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"∗"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal"},"d"),s("span",{class:"mord mathnormal"},"p"),s("span",{class:"mopen"},"["),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mclose"},"]")])])]),s("br"),a(" 其中 arr[x]*arr[y]=arr[i]")],-1),h=s("p",null,"考虑题目元素数量不大于1000，我们可以使用一个hash表做记忆化搜索。",-1),u=s("p",null,"具体看代码~",-1),v=s("h1",{id:"复杂度",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#复杂度","aria-hidden":"true"},"#"),a(" 复杂度")],-1),g=s("ul",null,[s("li",null,[s("p",null,[a("时间复杂度: "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",null,"+"),s("mi",null,"l"),s("mi",null,"o"),s("mi",null,"g"),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(n+logn)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mord mathnormal"},"o"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])])])]),s("li",null,[s("p",null,[a("空间复杂度: "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mn",null,"2"),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(2n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},"2"),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])])])])],-1),b=n(`<h1 id="code" tabindex="-1"><a class="header-anchor" href="#code" aria-hidden="true">#</a> Code</h1><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>  /**
     * dp 动态规划
     */
    class Solution {
        public int numFactoredBinaryTrees(int[] arr) {
            Arrays.sort(arr);
            long[] dps = new long[arr.length];
            Arrays.fill(dps, 1);
            Map&lt;Integer, Integer&gt; indez = new HashMap&lt;&gt;();

            long ans = 0;
            int mod = 1000_000_007;
            for (int i = 0; i &lt; dps.length; i++) {
                indez.put(arr[i], i);
                int cur = arr[i];
                for (int j = 0; j &lt; i &amp;&amp; arr[j] * arr[j] &lt;= arr[i]; j++) {
                    int pre = arr[j];
                    if (cur % pre == 0 &amp;&amp; indez.containsKey(cur / pre)) {
                        Integer index = indez.get(cur / pre);
                        dps[i] += index == j ? dps[j] * dps[j] : 2 * dps[j] * dps[index];
                    }
                }
                ans = (ans + dps[i]) % mod;
            }
            return (int) ans;
        }
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2);function y(x,_){const l=i("ExternalLinkIcon");return r(),t("div",null,[s("blockquote",null,[s("p",null,[s("a",d,[a("823. 带因子的二叉树"),m(l)])])]),o,p,h,u,v,g,b])}const k=e(c,[["render",y],["__file","2023年8月29日.html.vue"]]);export{k as default};
