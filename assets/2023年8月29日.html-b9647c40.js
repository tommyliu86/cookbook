const e=JSON.parse('{"key":"v-c7d77828","path":"/leetCode/everyday/2023%E5%B9%B48%E6%9C%8829%E6%97%A5.html","title":"2023年8月29日","lang":"zh-CN","frontmatter":{"title":"2023年8月29日","tag":["动态规划","哈希"]},"headers":[{"level":3,"title":"动态规划+哈希","slug":"动态规划-哈希","link":"#动态规划-哈希","children":[]}],"git":{"createdTime":1693272708000,"updatedTime":1693272708000,"contributors":[{"name":"liuwenfei@xiaomi.com","email":"liuwenfei@xiaomi.com","commits":1}]},"readingTime":{"minutes":1.38,"words":413},"filePathRelative":"leetCode/everyday/2023年8月29日.md","localizedDate":"2023年8月29日","excerpt":"<blockquote>\\n<p><a href=\\"https://leetcode.cn/problems/binary-trees-with-factors/description/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">823. 带因子的二叉树</a></p>\\n</blockquote>\\n<h1> 思路</h1>\\n<h3> 动态规划+哈希</h3>\\n<p>我们先从题目的要求进行分析，求的是能够构建多少二叉树？我们按照节点情况进行分析:</p>\\n<ol>\\n<li>所有的一个节点的二叉树</li>\\n<li>非一个节点的二叉树，此时必然有左、右子节点，且 <code>root=left*right</code> ，此时我们可以发现，我们只要找 三个数 并判断 是否满足乘法条件 即可。<br>\\n进一步，可以知道 left ，right &lt; root 成立 ，因此，思考如何判断是否可以构成二叉树 我们只要从小到大 遍历数组， 并在小于 <code>arr[i]</code> 的元素中找到 两个元素 x 和 y ,满足 <code>x*y=arr[i]</code></li>\\n</ol>"}');export{e as data};
