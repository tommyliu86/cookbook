const e=JSON.parse('{"key":"v-34a69ae8","path":"/leetCode/everyday/2023%E5%B9%B48%E6%9C%8825%E6%97%A5.html","title":"2023年8月25日","lang":"zh-CN","frontmatter":{"title":"2023年8月25日","tag":["二叉树","深度优先遍历"]},"headers":[{"level":3,"title":"深度优先遍历","slug":"深度优先遍历","link":"#深度优先遍历","children":[]}],"git":{"createdTime":1692926179000,"updatedTime":1692926179000,"contributors":[{"name":"liuwenfei@xiaomi.com","email":"liuwenfei@xiaomi.com","commits":1}]},"readingTime":{"minutes":0.74,"words":222},"filePathRelative":"leetCode/everyday/2023年8月25日.md","localizedDate":"2023年8月25日","excerpt":"<blockquote>\\n<p>LeetCode题目: <a href=\\"https://leetcode.cn/problems/count-good-nodes-in-binary-tree/description/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">1448. 统计二叉树中好节点的数目</a></p>\\n</blockquote>\\n<h1> 思路</h1>\\n<h3> 深度优先遍历</h3>\\n<p>分析题目，要求我们找到当前节点 curNode 到 root 的 path 上的所有值小于等于curNode，那我们只要记录当前点之前的最大值是多少即可<br>\\n因此直接使用深度优先遍历，遍历过程保留经过的点的最大值即可。</p>"}');export{e as data};
